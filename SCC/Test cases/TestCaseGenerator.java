package testCases.course2.assignment1SCC;

import utility.AbstractTestCaseGenerator;
import utility.ClassCaller;

import java.io.IOException;
import java.io.Serializable;
import java.lang.reflect.Method;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.StringTokenizer;
import java.util.concurrent.ThreadLocalRandom;

/**
 * An test case generator for courseX assignmentX.
 *
 * <p>Using this class's main method should be parameter driven. The convention is as follows:
 *
 * <p>java testCases.course2.assignment2SCC [method to call] [solver class] {[args to method]}
 *
 * <p>The [solver class] is used to ensure that test cases with unique solutions are produced.
 */
public class TestCaseGenerator extends AbstractTestCaseGenerator {
  public TestCaseGenerator(String methodToUse, String solverClassName, String[] args) {
    super(methodToUse, solverClassName, args);
  }

  /**
   * Run the TestCaseGenerator.
   *
   * @param args [method to call] [solver class] {[args to method]}
   */
  public static void main(String[] args) {
    AbstractTestCaseGenerator.main(TestCaseGenerator.class, args);
    TestCaseGenerator tcg =
        new TestCaseGenerator(args[0], args[1], Arrays.copyOfRange(args, 2, args.length));
    tcg.generateInputFiles();
  }

  /**
   * Creates test cases for the given graph sizes. The graph sizes are determined by the list of
   * ints that are provided as arguments.
   *
   * <p>A graph is generated by the following algorithm:
   *
   * <ol>
   *   <li>Shuffle an array of all potential vertices.
   *   <li>Choose a subset of the shuffled array to belong to a strongly connected component. The
   *       subset is no larger than half the size of the entire graph.
   *   <li>Create a cycle within that subset.
   *   <li>Occasionally (3% of the time), add another internal connection within the strongly
   *       connected component.
   * </ol>
   *
   * Repeat the above process until there are 5 strongly connected components. The remaining
   * vertices that have yet to be added to a component will be added to a sixth component.
   *
   * @param solverMainMethod the main method that gives a solution with the given file
   * @param args the filenameStartingIndex, followed by an array of numbers of vertices
   */
  public void mostlyCycles(Method solverMainMethod, String[] args) {
    int filenameStartingIndex = Integer.parseInt(args[0]);

    // Iterate through the command line arguments
    int argPointer = 1;
    while (argPointer < args.length) {

      System.out.println("Processing problem size => " + args[argPointer]);

      int numVertices = Integer.parseInt(args[argPointer++]);

      // A set of solutions.
      // Used to ensure 4 unique test case files are generated.
      HashSet<String> solutions = new HashSet<String>();

      while (solutions.size() < 4) {

        // Initialize the list of file lines
        HashSet<String> linesSet = new HashSet<String>();

        // Create the filename for the test case.
        String inputFilename = "input_mostlyCycles";
        inputFilename += "_" + filenameStartingIndex;
        inputFilename += "_" + numVertices;
        inputFilename += ".txt";

        // Add the lines to the lines array.

        // Create an array of vertices
        ArrayList<Integer> availableVertices = new ArrayList<Integer>();
        for (int i = 1; i <= numVertices; i++) {
          availableVertices.add(i);
        }

        // Shuffle the array of vertices
        Collections.shuffle(availableVertices);

        int componentsCount = 0;

        while (!availableVertices.isEmpty()) {
          int maxComponentSize = availableVertices.size();
          int numVerticesInThisComponent;
          // Take out a portion of the available vertices to put in a strongly connected component.
          maxComponentSize = Math.max(1, maxComponentSize);
          numVerticesInThisComponent = ThreadLocalRandom.current().nextInt(maxComponentSize) + 1;

          if (componentsCount == 5) {
            break;
          }

          // Put the next available vertices into a new array.
          ArrayList<Integer> thisComponentVertices = new ArrayList<Integer>();
          for (int i = 0; i < numVerticesInThisComponent && !availableVertices.isEmpty(); i++) {
            thisComponentVertices.add(availableVertices.remove(0));
          }

          // Create a cycle among the vertices in this component.
          // Occasionally, add another connection within this component.
          if (thisComponentVertices.size() > 1) {
            int startingVertex = thisComponentVertices.remove(0);
            int prevVertex = startingVertex;
            while (!thisComponentVertices.isEmpty()) {
              int vertex = thisComponentVertices.remove(0);
              // Potentially add some other internal connections.
              if (!thisComponentVertices.isEmpty()
                  && (ThreadLocalRandom.current().nextInt(101) < 20)) {
                int numInternalConnections =
                    ThreadLocalRandom.current()
                        .nextInt(1 + (int) Math.sqrt(numVerticesInThisComponent) / 10);
                for (int i = 0; i < numInternalConnections; i++) {
                  int internalVertexToConnect =
                      ThreadLocalRandom.current()
                          .nextInt((int) Math.sqrt(thisComponentVertices.size()));
                  linesSet.add(vertex + " " + thisComponentVertices.get(internalVertexToConnect));
                }
              }

              linesSet.add(prevVertex + " " + vertex);
              prevVertex = vertex;
            }
            // Connect the end of the cycle to the beginning
            linesSet.add(prevVertex + " " + startingVertex);
          }
        }

        ArrayList<String> lines = new ArrayList<String>(linesSet);

        // Sort the lines by tail vertex index
        lines.sort(new TailOrder());

        // Write the input file.
        Path file = Paths.get(inputFilename);
        try {
          Files.write(file, lines, Charset.forName("UTF-8"));
        } catch (IOException exception) {
          exception.printStackTrace();
        }

        String[] filenames = {inputFilename};

        String solution = ClassCaller.callMethod(solverMainMethod, filenames);

        // create an output file for this solution only if it is a unique solution.
        if (!solutions.contains(solution)) {
          // Add this solution to the set of solutions so far.
          solutions.add(solution);
          AbstractTestCaseGenerator.generateOutputFile(inputFilename, solution);
          System.out.println("\t" + solutions.size() + " unique file(s) generated.");
          filenameStartingIndex++;
        }
      }
    }
  }

  /**
   * A class to compare Strings by the integer value of the first token.
   *
   * @author beaunus
   */
  private static class TailOrder implements Comparator<String>, Serializable {

    /** Default value. */
    private static final long serialVersionUID = 1L;

    @Override
    public int compare(String s1, String s2) {
      StringTokenizer st1 = new StringTokenizer(s1);
      StringTokenizer st2 = new StringTokenizer(s2);
      int tail1 = Integer.parseInt(st1.nextToken());
      int head1 = Integer.parseInt(st1.nextToken());
      int tail2 = Integer.parseInt(st2.nextToken());
      int head2 = Integer.parseInt(st2.nextToken());
      if (tail1 > tail2) {
        return 1;
      }
      if (tail2 > tail1) {
        return -1;
      }
      if (head1 > head2) {
        return 1;
      }
      if (head2 > head1) {
        return -1;
      }
      return 0;
    }
  }
}
